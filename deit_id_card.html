<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ID卡编辑器</title>
    {{ font_load }}
    <style>
        #canvas {
            /*border: 1px solid #000;*/
            /*width: 500px; 宽改成自适应*/
            width: 500px;
            height: 500px;
            position: relative;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        #avatar-container {
            position: absolute;
            cursor: move;
            transform-origin: top left;
        }

        #avatar {
            width: 80px;
            height: 80px;
            border-radius: 0%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .text-container {
            position: absolute;
            top: 120px;
            left: 100px;
            cursor: move;
            transform-origin: top left;
        }

        .text {
            font-size: 20px;
            font-family: Arial;
        }

        .bordered {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<h1>ID卡编辑器</h1>
<br>
<label for="background-input">
    选择背景图像：
    <input type="file" id="background-input" accept="image/*">
</label>
<br>
<div id="canvas"></div>
<br>
<label for="avatar-input">
    选择头像图像：
    <input type="file" id="avatar-input" accept="image/*">
</label>
<br>


<script>
    let backgroundImg;
    let avatarImg;
    const canvas = document.getElementById('canvas');
    const avatarContainer = document.createElement('div');
    avatarContainer.id = 'avatar-container';

    // 上传背景图片
    document.getElementById('background-input').addEventListener('change', handleBackgroundChange);

    // 上传用户头像
    const avatar = document.createElement('div'); //上传完再创建
    document.getElementById('avatar-input').addEventListener('change', function (event) {
        avatar.id = 'avatar';

        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function (e) {
            avatarImg = e.target.result;
            avatar.style.backgroundImage = `url(${avatarImg})`;
        };
        reader.readAsDataURL(file);

        avatarContainer.appendChild(avatar);
        canvas.appendChild(avatarContainer);
    });

    // // 文字编辑
    // document.getElementById('text-input').addEventListener('input', function (event) {
    //     const textContent = event.target.value;
    //     text.innerHTML = textContent;
    // });

    // 头像拖动功能
    avatarContainer.addEventListener('mousedown', function (event) {
        event.preventDefault();
        let prevX = event.clientX;
        let prevY = event.clientY;
        document.addEventListener('mousemove', moveAvatar);

        document.addEventListener('mouseup', function () {
            document.removeEventListener('mousemove', moveAvatar);
        });

        function moveAvatar(event) {
            const newX = avatarContainer.offsetLeft + (event.clientX - prevX);
            const newY = avatarContainer.offsetTop + (event.clientY - prevY);
            avatarContainer.style.left = `${newX}px`;
            avatarContainer.style.top = `${newY}px`;
            prevX = event.clientX;
            prevY = event.clientY;
        }
    });

    // 文字拖动功能
    // textContainer.addEventListener('mousedown', function (event) {
    //     event.preventDefault();
    //     let prevX = event.clientX;
    //     let prevY = event.clientY;
    //     document.addEventListener('mousemove', moveText);
    //
    //     document.addEventListener('mouseup', function () {
    //         document.removeEventListener('mousemove', moveText);
    //     });
    //
    //     function moveText(event) {
    //         const newX = textContainer.offsetLeft + (event.clientX - prevX);
    //         const newY = textContainer.offsetTop + (event.clientY - prevY);
    //         textContainer.style.left = `${newX}px`;
    //         textContainer.style.top = `${newY}px`;
    //         prevX = event.clientX;
    //         prevY = event.clientY;
    //     }
    // });

    // Function to handle adjusting canvas size based on aspect ratio
    function adjustCanvasSizeForAspectRatio(img) {
        const aspectRatio = img.width / img.height;
        const canvasWidth = canvas.offsetWidth;
        const canvasHeight = canvasWidth / aspectRatio;
        canvas.style.height = `${canvasHeight}px`;
        canvas.style.width = `${canvasWidth}px`;
        // canvas.style.height = `${canvasHeight}px`;
    }

    // Function to handle background image change
    function handleBackgroundChange(event) {
        const file = event.target.files[0];
        const img = new Image();
        const reader = new FileReader();

        reader.onload = function (e) {
            img.src = e.target.result;
            img.onload = function () {
                // Adjust canvas size based on aspect ratio
                adjustCanvasSizeForAspectRatio(img);

                // Set background image
                backgroundImg = e.target.result;
                canvas.style.backgroundImage = `url(${backgroundImg})`;
            };
        };
        reader.readAsDataURL(file);
    }
</script>

<input type="checkbox" id="avatar-round-input">
<label for="avatar-round-input">头像是否圆角</label>
<br>
<!-- 省略部分代码 -->
<!--<input type="range" id="text-size-input" min="20" max="100" value="20">文字大小</input>-->
<!--<br>-->
<input type="range" id="avatar-size-input" min="20" max="300" value="100">头像大小</input>
<br>

<!-- 省略部分代码 -->

<script>
    // 文字大小编辑
    // var var_textsize;
    // document.getElementById('text-size-input').addEventListener('input', function (event) {
    //     const textSize = event.target.value;
    //     var_textsize = textSize
    //     text.style.fontSize = `${textSize}px`;
    // });

    // 头像大小编辑
    document.getElementById('avatar-size-input').addEventListener('input', function (event) {
        const avatarSize = event.target.value;
        avatar.style.width = `${avatarSize}px`;
        avatar.style.height = `${avatarSize}px`;
    });
    // 头像圆角编辑
    document.getElementById('avatar-round-input').addEventListener('change', function (event) {
        const isRound = event.target.checked;
        if (isRound) {
            avatar.style.borderRadius = '50%';
        } else {
            avatar.style.borderRadius = '0';
        }
    });

    // 省略其他代码
</script>
<!--<input type="color" id="text-color-input" value="#000000">-->
<!--<br>-->

<!-- 省略部分代码 -->

<!--<script>-->
<!--    // 省略其他代码-->

<!--    // 文字颜色编辑-->
<!--    document.getElementById('text-color-input').addEventListener('input', function (event) {-->
<!--        const textColor = event.target.value;-->
<!--        text.style.color = textColor;-->
<!--    });-->
<!--    // 省略其他代码-->
<!--</script>-->
<!-- 省略部分代码 -->

<!-- 省略部分代码 -->
<!--<select id="font-family-select">-->
<!--    <option value="Arial">Arial</option>-->
<!--    <option value="Verdana">Verdana</option>-->
<!--    <option value="Helvetica">Helvetica</option>-->
<!--    <option value="Times New Roman">Times New Roman</option>-->
<!--    <option value="Courier New">Courier New</option>-->
<!--</select>-->
<!--<br>-->

<!-- 省略部分代码 -->

<!--<script>-->
<!--    // 省略其他代码-->
<!--    // 文字字体编辑-->
<!--    document.getElementById('font-family-select').addEventListener('change', function (event) {-->
<!--        const fontFamily = event.target.value;-->
<!--        text.style.fontFamily = fontFamily;-->
<!--    });-->
<!--    // 省略其他代码-->
<!--</script>-->

<!-- ... existing HTML code ... -->
<script>
    class TextData {
        constructor() {
            this.position = {left: 100, top: 120};
            this.content = "";
            this.fontSize = "20px";
            this.color = "#000000";
            this.fontFamily = "Arial";
            this.isTemplate = false;
        }
    }

    class TemplateData {
        constructor() {
            this.background = {
                size: {width: 0, height: 0},
                imageUrl: "",
            };
            this.avatar = {
                imageUrl: "",
                size: {width: 0, height: 0},
                position: {left: 0, top: 0},
                rounded: false, // 是否圆角
                colName: "avatar", // 本地路径也是可以的吧
            };
            this.textList = []

        }
    }

    // ... existing code ...

    // Save templateData as JSON
    function saveTemplate() {
        // Collect all the data before saving
        var templateData = new TemplateData()
        templateData.background.imageUrl = canvas.style.backgroundImage;
        templateData.background.size.width = canvas.offsetWidth;
        templateData.background.size.height = canvas.offsetHeight;
        templateData.avatar.position = {
            left: avatarContainer.offsetLeft,
            top: avatarContainer.offsetTop
        };

        const computedStyle = getComputedStyle(avatar);
        const height = computedStyle.height;
        const width = computedStyle.width;

        let avatarHeight = avatar.style.height
        let avatarWidth = avatar.style.width
        if (avatarHeight === '') {
            avatarHeight = height;
        }
        if (avatarWidth === '') {
            avatarWidth = width;
        }
        templateData.avatar.size.height = avatarHeight;  // 高
        templateData.avatar.size.width = avatarWidth;  // 宽
        templateData.avatar.colName = avatarCol.value;  // 宽
        // 遍历和记录textlist 列表的数据

        children = canvas.children;
        for (let i = 0; i < children.length; i++) {
            if (children[i].className === "text-container") {
                let textDiv = children[i].children[0];
                let oneTextData = new TextData();
                oneTextData.fontSize = textDiv.style.fontSize;
                oneTextData.color = textDiv.style.color;
                oneTextData.isTemplate = JSON.parse(textDiv.getAttribute("istemplate")); // 转化为布尔值
                oneTextData.position.left = children[i].offsetLeft;
                oneTextData.position.top = children[i].offsetTop;
                oneTextData.fontFamily = textDiv.style.fontFamily;
                oneTextData.content = textDiv.content;
                oneTextData.colName = textDiv.getAttribute("colname");  // 对应的Colname 需要指定映射的
                // ps 确实可以，但是我要自动化，要方便批量的。
                templateData.textList.push(oneTextData);
                console.log(oneTextData);
            }
        }

        const templateJson = JSON.stringify(templateData);
        console.log(templateJson); // You can save this JSON data to a file, local storage, or a server
        const blob = new Blob([templateJson], {type: 'application/json'});
        const fileName = 'template.json';

        if (window.navigator.msSaveOrOpenBlob) {
            // For IE:
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        } else {
            // For other browsers:
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

    }
</script>
<!--<button onclick="renderImage()">生成ID卡</butt on>-->

<!-- 修改和旋转背景图的东西，省略部分代码 -->

<h2>下面是动态增加文字列表的功能</h2>
<button id="add-text-button">新增文字</button>
<div id="text-list-container">

</div>

<script>
    const addTextButton = document.getElementById('add-text-button');
    const textListContainer = document.getElementById('text-list-container');
    const textList = [];

    addTextButton.addEventListener('click', function () {
        const newText = createTextElement();
        textList.push(newText);
        textListContainer.appendChild(newText);
    });

    function createTextElement() {
        const textElement = document.createElement('div');
        textElement.classList.add('text-item');
        textElement.className = "bordered"  // 增加边框线条

        const textContentInput = document.createElement('input');
        textContentInput.setAttribute('type', 'text');
        textContentInput.setAttribute('placeholder', '输入文字');
        textElement.appendChild(textContentInput);


        const textSizeInput = document.createElement('input');
        textSizeInput.setAttribute('type', 'range');
        textSizeInput.setAttribute('min', '20');
        textSizeInput.setAttribute('max', '100');
        textSizeInput.setAttribute('value', '20');
        textElement.appendChild(textSizeInput);

        const textColorInput = document.createElement('input');
        textColorInput.setAttribute('type', 'color');
        textColorInput.setAttribute('value', '#000000');
        textElement.appendChild(textColorInput);


        // 设置对应的列，如果需要映射替换的话
        const subInputColName = document.createElement('input');
        subInputColName.placeholder = "请输入对应与csv表格的列名";
        subInputColName.style.display = 'none';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        // 设置 checkbox 的属性和事件处理程序
        checkbox.id = 'isTemplate';
        checkbox.name = 'isTemplate';
        checkbox.value = false;
        checkbox.checked = false; // 设置为选中状态

        const brDiv = document.createElement('br');
        textElement.appendChild(brDiv);
        const label = document.createElement('label');
        label.textContent = "是否是映射列？："
        label.appendChild(checkbox)
        textElement.appendChild(label);
        textElement.appendChild(subInputColName);  // 各自有各自的乐趣，不就好了， 这有什么不好的呢！

        const subText = document.createElement('div');
        subText.className = 'text';
        subText.setAttribute("isTemplate", false);

        checkbox.addEventListener('change', function () {
            if (checkbox.checked) {
                console.log('Checkbox is checked');
                subText.setAttribute("isTemplate", true);
                subInputColName.style.display = 'block';
                subText.setAttribute("colName", subInputColName.value); // 改动了就顺便设置修改一下
            } else {
                console.log('Checkbox is unchecked');
                subText.setAttribute("isTemplate", false);
                subInputColName.style.display = 'none';
                subText.setAttribute("colName", ""); // 改动了就顺便设置修改一下

            }
        });
        subInputColName.addEventListener("change", function () {
            subText.setAttribute("colName", subInputColName.value); // 改动了就顺便设置修改一下
        });

        const subTextContainer = document.createElement('div');
        subTextContainer.className = 'text-container';
        subTextContainer.appendChild(subText)
        subTextContainer.addEventListener('mousedown', function (event) {
            event.preventDefault();
            let prevX = event.clientX;
            let prevY = event.clientY;
            document.addEventListener('mousemove', moveText);

            document.addEventListener('mouseup', function () {
                document.removeEventListener('mousemove', moveText);
            });

            function moveText(event) {
                const newX = subTextContainer.offsetLeft + (event.clientX - prevX);
                const newY = subTextContainer.offsetTop + (event.clientY - prevY);
                subTextContainer.style.left = `${newX}px`;
                subTextContainer.style.top = `${newY}px`;
                prevX = event.clientX;
                prevY = event.clientY;
            }
        });
        canvas.appendChild(subTextContainer)

        //动态创建给每一个字体设置字体的selector； todo 还需要增加一个删除这个dom和对象的功能
        const subFontSelector = document.createElement('select');  // 给这个元素创造一个 列表选择字体
        let loadedFonts = Array.from(document.fonts);
        loadedFonts.forEach(function (font) {
            let option = document.createElement("option");
            option.text = font.family;
            option.value = font.family;
            subFontSelector.add(option);
        });
        subFontSelector.value = loadedFonts[0].family; // 默认第一个选项为默认选项
        subText.style.fontFamily = loadedFonts[0].family; //  后续修改后再自动改变就可以
        subFontSelector.addEventListener("change", function (event) {
            let fontFamily = subFontSelector.value;
            subText.style.fontFamily = fontFamily;
        });
        textElement.appendChild(subFontSelector)  // 增加select选择器

        // canvas.appendChild(subText)
        textContentInput.addEventListener('input', function () {
            const subTextContent = event.target.value;
            subText.innerHTML = subTextContent;
        });

        textContentInput.addEventListener('input', function () {
            const subTextContent = event.target.value;
            subText.innerHTML = subTextContent;
            subText.content = textContentInput.value;
            // 在这里更新对应的 Text 对象的 content 属性 ； 直接设置不同对象的监听器
        });
        textSizeInput.addEventListener('input', function (event) {
            const textSize = event.target.value;
            subText.style.fontSize = `${textSize}px`;
            // subText.fontSize = textSizeInput.value;
            // 在这里更新对应的 Text 对象的 size 属性
        });
        textColorInput.addEventListener('input', function (event) {
            const textColor = event.target.value;
            subText.style.color = textColor;
            // 在这里更新对应的 Text 对象的 color 属性
        });

        //增加删除文字元素的按钮操作，同时删除canvas上的文字元素
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-btn';
        deleteButton.textContent = '删除此文字';
        deleteButton.addEventListener('click', function () {
            textElement.remove(textElement); // 把父元素都删除
            canvas.removeChild(subTextContainer);
        });
        textElement.appendChild(deleteButton);
        return textElement;
    }

</script>
<br><br>

<label>
    avatar name match col name:default is 'avatar'<br>
    <input id='avatarCol' value='avatar' placeholder="avatar">
</label>
<br>
<!--保存此次的配置-->

<!--<select onclick="saveTemplate()">加载已保存的模版</>-->
<button onclick="saveTemplate()">保存编辑的配置模版</button>
<br>

<!--上传头像文件夹-->
<h2>Upload Folder</h2>
<form id="uploadForm" enctype="multipart/form-data">
    <input type="file" id="folderInput" webkitdirectory directory multiple/>
    <button type="button" onclick="uploadFiles()">Upload</button>
</form>
<script>
    function checkFileExtension(filenames) {
        let imageFlag = false;
        let excelFlag = false;
        let jsonFlag = false;

        for (const filename of filenames) {
            const extension = filename.split('.').pop().toLowerCase();
            // 图片后缀名数组
            const imageExtensions = ['jpg', 'jpeg', 'png', 'gif'];
            // Excel 后缀名数组
            const excelExtensions = ['xlsx', 'xls'];
            // JSON 后缀名数组
            const jsonExtensions = ['json'];

            // 检查文件后缀名是否在对应的数组中
            if (imageExtensions.includes(extension)) {
                imageFlag = true;
            } else if (excelExtensions.includes(extension)) {
                excelFlag = true;
            } else if (jsonExtensions.includes(extension)) {
                jsonFlag = true;
            } else {
            }
        }
        const flags = [imageFlag, excelFlag, jsonFlag];
        return flags.every(Boolean);   // 这几种文件都有的情况下才上传
    }
</script>
<script>
    let storeFolder = "";
    let storeFiles = []

    function upload() {
        const input = document.getElementById('folderInput');
        const files = input.files;

        if (files.length > 0) {
            const formData = new FormData();

            for (let i = 0; i < files.length; i++) {
                formData.append('files[]', files[i], files[i].name);
            }

            fetch('/upload_folder', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    console.log(data);
                    storeFolder = data.storeFolder;
                    storeFiles = data.storeFiles;
                    alert('上传成功！请点击批量处理！');
                })
                .catch(error => console.error('Error:', error));
        } else {
            alert('No files selected!');
            console.info('No files selected.');
        }
    }

    function uploadFiles() {
        if (storeFolder === '') {
            upload();
        } else {
            // 确认一下需不需要重新上传
            let result = confirm("你确定要重新上传所有文件吗？");
            if (result) {
                upload();
                // 用户点击了“确定”按钮
                // 执行相应的操作
            } else {
                // 用户点击了“取消”按钮或关闭了对话框
                // 执行其他操作或不执行任何操作
            }
        }

    }
</script>
<script>
    //开始按照模版批量处理
    //默认使用当前编辑中的模版
    function sendBatchRequest(jsonData) {
        fetch('/batch_processing', {
            method: 'POST',
            body: JSON.stringify(jsonData),
            responseType: 'json',
            headers: {
                'Content-Type': 'application/json'
            },
        })
            .then(response => response.json())
            .then(data => {
                // data.storePath
                console.log(data);
                console.log(data.outputPath);
                console.log("接收文件成功");
                const link = document.createElement('a');
                // link.innerText = "点击此处下载！"
                let url = data.outputPath;
                link.download = '';
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            })
            .catch(error => console.error('Error:', error));
    }

    function batchProcess() {
        if (storeFolder === '') {
            alert("请先把1生成的配置文件xx.json；2所有头像图片；3映射关系excel表一次性上传好");
        } else {
            const jsonData = {static_path: storeFolder};
            sendBatchRequest(jsonData); // 启动项目，发送storeFoler路径
        }
    }

</script>

<button onclick="batchProcess()">开始批量处理</button>
<br>
</body>
</html>
